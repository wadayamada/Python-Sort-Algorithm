# ソート・探索

## ソート

### 選択ソート

> データ列中で一番小さい値を探し、1番目の要素と交換する。次に、2番目以降のデータ列から一番小さい値を探し、2番目の要素と交換する。これを、データ列の最後まで繰り返す

[選択ソート \- Wikipedia](https://ja.wikipedia.org/wiki/%E9%81%B8%E6%8A%9E%E3%82%BD%E3%83%BC%E3%83%88#:~:text=%E9%81%B8%E6%8A%9E%E3%82%BD%E3%83%BC%E3%83%88%EF%BC%88%E8%8B%B1%3A%20selection%20sort,%E3%81%AA%E3%81%9F%E3%82%81%E3%80%81%E3%81%97%E3%81%B0%E3%81%97%E3%81%B0%E7%94%A8%E3%81%84%E3%82%89%E3%82%8C%E3%82%8B%E3%80%82)

### クイックソート

> 1. 適当な数（ピボットという）を選択する（この場合は[データ](https://ja.wikipedia.org/wiki/データ)の総数の[中央値](https://ja.wikipedia.org/wiki/中央値)が望ましい）
> 2. ピボットより小さい数を前方、大きい数を後方に移動させる （分割）
> 3. 二分割された各々のデータを、それぞれソートする

[クイックソート \- Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88#:~:text=%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88%20(quicksort)%20%E3%81%AF%E3%80%81,%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95%E3%81%AE%E4%B8%80%E7%A8%AE%E3%80%82)

### マージソート

> 1. データ列を分割する（通常、二等分する）
> 2. 分割された各データ列で、含まれるデータが1個ならそれを返し、2個以上ならステップ1から3を再帰的に適用してマージソートする
> 3. 二つのソートされたデータ列（1個であればそれ自身）をマージする

[マージソート \- Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%9E%E3%83%BC%E3%82%B8%E3%82%BD%E3%83%BC%E3%83%88#:~:text=%E3%83%9E%E3%83%BC%E3%82%B8%E3%82%BD%E3%83%BC%E3%83%88%E3%81%AF%E3%80%81%E3%82%BD%E3%83%BC%E3%83%88%E3%81%AE,%E4%BD%9C%E6%A5%AD%E3%81%AF%E4%B8%A6%E5%88%97%E5%8C%96%E3%81%A7%E3%81%8D%E3%82%8B%E3%80%82)

### バブルソート

> 全ての要素に関して、隣接する要素と比較し順序が逆であれば入れ替える。これを要素数-1回繰り返すことでソートを行なう。

[バブルソート \- Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%96%E3%83%AB%E3%82%BD%E3%83%BC%E3%83%88)

### ヒープソート

> ヒープソートの考え方は、まず、データをヒープ構造にし、完成したらデータの先頭の値を取り出す。そしてまたヒープ構造を作り・・・という繰り返しである。
>
> ここでヒープ構造とは、簡単に言うと、２分木の各節点にデータを保持し、親のデータが2つの子のデータよりも大きくなるように作られたデータ構造である。
>
> つまり、これから分かることは全てのデータの中で２分木の「根」、すなわちデータの先頭に最大値を持つデータが必ず存在する。という事である。

[ヒープソート](http://www.th.cs.meiji.ac.jp/assets/researches/2005/omoto/heapsort.html)

[ヒープソートとは \| 分かりやすく図解で解説 \- ITを分かりやすく解説](https://medium-company.com/%E3%83%92%E3%83%BC%E3%83%97%E3%82%BD%E3%83%BC%E3%83%88/)

### 挿入ソート

> まず0番目と1番目の要素を比較し、順番が逆であれば入れ換える。次に、2番目の要素が1番目までの要素より小さい場合、正しい順に並ぶように「挿入」する（配列の場合、前の要素を後ろに一つずつずらす）。この操作で、2番目までのデータが整列済みとなる（ただし、さらにデータが挿入される可能性があるので確定ではない）。このあと、3番目以降の要素について、整列済みデータとの比較と適切な位置への挿入を繰り返す。

[挿入ソート \- Wikipedia](https://ja.wikipedia.org/wiki/%E6%8C%BF%E5%85%A5%E3%82%BD%E3%83%BC%E3%83%88#:~:text=%E6%8C%BF%E5%85%A5%E3%82%BD%E3%83%BC%E3%83%88%EF%BC%88%E3%82%A4%E3%83%B3%E3%82%B5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%BD%E3%83%BC%E3%83%88,%E5%AE%89%E5%AE%9A%E3%81%AA%E5%86%85%E9%83%A8%E3%82%BD%E3%83%BC%E3%83%88%E3%80%82)

## 探索アルゴリズム

### 線形探索

> リストや配列に入ったデータに対する検索を行うにあたって、 先頭から順に比較を行い、それが見つかれば終了する。

[線型探索 \- Wikipedia](https://ja.wikipedia.org/wiki/%E7%B7%9A%E5%9E%8B%E6%8E%A2%E7%B4%A2)
